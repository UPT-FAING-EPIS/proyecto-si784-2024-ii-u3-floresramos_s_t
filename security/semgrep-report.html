
            <html>
                <head>
                    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.1/css/bootstrap.min.css">
                    <style>body{ margin:0 100; background:whitesmoke; }</style>
                </head>
<!-- 
{
  "meta": {
    "commit_author": null,
    "commit_branch": null,
    "commit_date": null,
    "commit_sha": null,
    "commit_title": null,
    "filtered_message_count": 62,
    "mr_iid": null,
    "mr_source_branch": null,
    "mr_target_branch": null,
    "mr_title": null,
    "pipeline_date": null,
    "pipeline_job_date": null,
    "pipeline_job_image": null,
    "pipeline_job_name": null,
    "pipeline_job_stage": null,
    "pipeline_job_started_by_email": null,
    "pipeline_job_started_by_id": null,
    "pipeline_job_started_by_login": null,
    "pipeline_job_started_by_name": null,
    "pipeline_job_url": null,
    "pipeline_project_group": null,
    "pipeline_project_group_root": null,
    "pipeline_project_name": null,
    "pipeline_project_path": null,
    "pipeline_project_path_slug": null,
    "pipeline_project_url": null,
    "pipeline_server_url": null,
    "pipeline_url": null,
    "report_date": "2024-12-14 01:53:57.917483",
    "report_from_ci": false,
    "total_message_count": 62
  }
}
-->
                <body>
            <table id="info-table" class="table table-bordered table-hover"><thead><tr><th>tool</th><th>code</th><th>severity</th><th>confidence</th><th>function</th><th>file</th><th>line</th><th>position</th><th>message</th></tr></thead><tbody><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/common/socksProxy.js</td><td>296</td><td>10</td><td>RegExp() called with a `pattern` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/protocol/serializers.js</td><td>49</td><td>37</td><td>RegExp() called with a `value` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/server/bidi/third_party/bidiDeserializer.js</td><td>52</td><td>16</td><td>RegExp() called with a `result` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.detect-insecure-websocket.detect-insecure-websocket</td><td>ERROR</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/server/chromium/chromium.js</td><td>322</td><td>172</td><td>Insecure WebSocket Detected. WebSocket Secure (wss) should be used for all WebSocket connections.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.detect-insecure-websocket.detect-insecure-websocket</td><td>ERROR</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/server/chromium/chromium.js</td><td>335</td><td>10</td><td>Insecure WebSocket Detected. WebSocket Secure (wss) should be used for all WebSocket connections.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/server/dispatchers/browserContextDispatcher.js</td><td>240</td><td>98</td><td>RegExp() called with a `params` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/server/dispatchers/browserContextDispatcher.js</td><td>241</td><td>104</td><td>RegExp() called with a `params` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/server/dispatchers/browserContextDispatcher.js</td><td>242</td><td>98</td><td>RegExp() called with a `params` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/server/dispatchers/browserContextDispatcher.js</td><td>275</td><td>78</td><td>RegExp() called with a `pattern` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.detect-insecure-websocket.detect-insecure-websocket</td><td>ERROR</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/server/dispatchers/localUtilsDispatcher.js</td><td>396</td><td>177</td><td>Insecure WebSocket Detected. WebSocket Secure (wss) should be used for all WebSocket connections.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/server/dispatchers/pageDispatcher.js</td><td>172</td><td>78</td><td>RegExp() called with a `pattern` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/server/dispatchers/webSocketRouteDispatcher.js</td><td>185</td><td>44</td><td>RegExp() called with a `dispatcher` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.browser.security.insecure-document-method.insecure-document-method</td><td>ERROR</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/server/frames.js</td><td>791</td><td>11</td><td>User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/server/har/harRecorder.js</td><td>40</td><td>103</td><td>RegExp() called with a `options` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/server/isomorphic/utilityScriptSerializers.js</td><td>76</td><td>32</td><td>RegExp() called with a `value` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>problem-based-packs.insecure-transport.js-node.bypass-tls-verification.bypass-tls-verification</td><td>WARNING</td><td>MEDIUM</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/server/socksClientCertificatesInterceptor.js</td><td>65</td><td>41</td><td>Checks for setting the environment variable NODE_TLS_REJECT_UNAUTHORIZED to 0, which disables TLS verification. This should only be used for debugging purposes. Setting the option rejectUnauthorized to false bypasses verification against the list of trusted CAs, which also leads to insecure transport. These options lead to vulnerability to MTM attacks, and should not be used.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utils/isomorphic/ariaSnapshot.js</td><td>81</td><td>57</td><td>RegExp() called with a `value` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utils/isomorphic/locatorGenerators.js</td><td>253</td><td>11</td><td>RegExp() called with a `text` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utils/isomorphic/locatorParser.js</td><td>147</td><td>162</td><td>RegExp() called with a `ordinal` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utils/isomorphic/locatorParser.js</td><td>147</td><td>162</td><td>RegExp() called with a `params` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utils/isomorphic/locatorParser.js</td><td>147</td><td>162</td><td>RegExp() called with a `template` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utils/isomorphic/locatorParser.js</td><td>147</td><td>162</td><td>RegExp() called with a `testIdAttributeName` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utils/isomorphic/locatorParser.js</td><td>148</td><td>54</td><td>RegExp() called with a `ordinal` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utils/isomorphic/locatorParser.js</td><td>148</td><td>54</td><td>RegExp() called with a `params` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utils/isomorphic/locatorParser.js</td><td>148</td><td>54</td><td>RegExp() called with a `suffix` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utils/isomorphic/locatorParser.js</td><td>148</td><td>54</td><td>RegExp() called with a `template` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utils/isomorphic/locatorParser.js</td><td>148</td><td>54</td><td>RegExp() called with a `testIdAttributeName` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.spawn-shell-true.spawn-shell-true</td><td>ERROR</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utils/processLauncher.js</td><td>198</td><td>35</td><td>Found &#x27;$SPAWN&#x27; with &#x27;{shell: true}&#x27;. This is dangerous because this call will spawn the command using a shell process. Doing so propagates current shell settings and variables, which makes it much easier for a malicious actor to execute commands. Use &#x27;{shell: false}&#x27; instead.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.detect-insecure-websocket.detect-insecure-websocket</td><td>ERROR</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utils/wsServer.js</td><td>65</td><td>81</td><td>Insecure WebSocket Detected. WebSocket Secure (wss) should be used for all WebSocket connections.</td></tr><tr><td>semgrep</td><td>bash.lang.security.ifs-tampering.ifs-tampering</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utilsBundleImpl/xdg-open</td><td>153</td><td>5</td><td>The special variable IFS affects how splitting takes place when expanding unquoted variables. Don&#x27;t set it globally. Prefer a dedicated utility such as &#x27;cut&#x27; or &#x27;awk&#x27; if you need to split input data. If you must use &#x27;read&#x27;, set IFS locally using e.g. &#x27;IFS=&quot;,&quot; read -a my_array&#x27;.</td></tr><tr><td>semgrep</td><td>bash.lang.security.ifs-tampering.ifs-tampering</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utilsBundleImpl/xdg-open</td><td>181</td><td>5</td><td>The special variable IFS affects how splitting takes place when expanding unquoted variables. Don&#x27;t set it globally. Prefer a dedicated utility such as &#x27;cut&#x27; or &#x27;awk&#x27; if you need to split input data. If you must use &#x27;read&#x27;, set IFS locally using e.g. &#x27;IFS=&quot;,&quot; read -a my_array&#x27;.</td></tr><tr><td>semgrep</td><td>bash.lang.security.ifs-tampering.ifs-tampering</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utilsBundleImpl/xdg-open</td><td>537</td><td>5</td><td>The special variable IFS affects how splitting takes place when expanding unquoted variables. Don&#x27;t set it globally. Prefer a dedicated utility such as &#x27;cut&#x27; or &#x27;awk&#x27; if you need to split input data. If you must use &#x27;read&#x27;, set IFS locally using e.g. &#x27;IFS=&quot;,&quot; read -a my_array&#x27;.</td></tr><tr><td>semgrep</td><td>bash.lang.security.ifs-tampering.ifs-tampering</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utilsBundleImpl/xdg-open</td><td>556</td><td>5</td><td>The special variable IFS affects how splitting takes place when expanding unquoted variables. Don&#x27;t set it globally. Prefer a dedicated utility such as &#x27;cut&#x27; or &#x27;awk&#x27; if you need to split input data. If you must use &#x27;read&#x27;, set IFS locally using e.g. &#x27;IFS=&quot;,&quot; read -a my_array&#x27;.</td></tr><tr><td>semgrep</td><td>bash.lang.security.ifs-tampering.ifs-tampering</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utilsBundleImpl/xdg-open</td><td>867</td><td>5</td><td>The special variable IFS affects how splitting takes place when expanding unquoted variables. Don&#x27;t set it globally. Prefer a dedicated utility such as &#x27;cut&#x27; or &#x27;awk&#x27; if you need to split input data. If you must use &#x27;read&#x27;, set IFS locally using e.g. &#x27;IFS=&quot;,&quot; read -a my_array&#x27;.</td></tr><tr><td>semgrep</td><td>bash.lang.security.ifs-tampering.ifs-tampering</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/utilsBundleImpl/xdg-open</td><td>869</td><td>9</td><td>The special variable IFS affects how splitting takes place when expanding unquoted variables. Don&#x27;t set it globally. Prefer a dedicated utility such as &#x27;cut&#x27; or &#x27;awk&#x27; if you need to split input data. If you must use &#x27;read&#x27;, set IFS locally using e.g. &#x27;IFS=&quot;,&quot; read -a my_array&#x27;.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/vite/traceViewer/assets/workbench-DsQEOQud.js</td><td>1</td><td>9510</td><td>RegExp() called with a `t` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>typescript.react.security.audit.react-dangerouslysetinnerhtml.react-dangerouslysetinnerhtml</td><td>WARNING</td><td>MEDIUM</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/vite/traceViewer/assets/workbench-DsQEOQud.js</td><td>1</td><td>10468</td><td>Detection of dangerouslySetInnerHTML from non-constant definition. This can inadvertently expose users to cross-site scripting (XSS) attacks if this comes from user-provided input. If you have to use dangerouslySetInnerHTML, consider using a sanitization library such as DOMPurify to sanitize your HTML.</td></tr><tr><td>semgrep</td><td>javascript.browser.security.wildcard-postmessage-configuration.wildcard-postmessage-configuration</td><td>WARNING</td><td>MEDIUM</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/vite/traceViewer/embedded.D4x_-tXl.js</td><td>1</td><td>162</td><td>The target origin of the window.postMessage() API is set to &quot;*&quot;. This could allow for information disclosure due to the possibility of any origin allowed to receive the message.</td></tr><tr><td>semgrep</td><td>javascript.browser.security.wildcard-postmessage-configuration.wildcard-postmessage-configuration</td><td>WARNING</td><td>MEDIUM</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/vite/traceViewer/embedded.D4x_-tXl.js</td><td>1</td><td>278</td><td>The target origin of the window.postMessage() API is set to &quot;*&quot;. This could allow for information disclosure due to the possibility of any origin allowed to receive the message.</td></tr><tr><td>semgrep</td><td>javascript.browser.security.insufficient-postmessage-origin-validation.insufficient-postmessage-origin-validation</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/vite/traceViewer/embedded.D4x_-tXl.js</td><td>1</td><td>512</td><td>No validation of origin is done by the addEventListener API. It may be possible to exploit this flaw to perform Cross Origin attacks such as Cross-Site Scripting(XSS).</td></tr><tr><td>semgrep</td><td>javascript.browser.security.wildcard-postmessage-configuration.wildcard-postmessage-configuration</td><td>WARNING</td><td>MEDIUM</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/vite/traceViewer/embedded.D4x_-tXl.js</td><td>1</td><td>686</td><td>The target origin of the window.postMessage() API is set to &quot;*&quot;. This could allow for information disclosure due to the possibility of any origin allowed to receive the message.</td></tr><tr><td>semgrep</td><td>javascript.browser.security.wildcard-postmessage-configuration.wildcard-postmessage-configuration</td><td>WARNING</td><td>MEDIUM</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/vite/traceViewer/embedded.D4x_-tXl.js</td><td>1</td><td>1322</td><td>The target origin of the window.postMessage() API is set to &quot;*&quot;. This could allow for information disclosure due to the possibility of any origin allowed to receive the message.</td></tr><tr><td>semgrep</td><td>javascript.browser.security.wildcard-postmessage-configuration.wildcard-postmessage-configuration</td><td>WARNING</td><td>MEDIUM</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/vite/traceViewer/embedded.D4x_-tXl.js</td><td>1</td><td>1856</td><td>The target origin of the window.postMessage() API is set to &quot;*&quot;. This could allow for information disclosure due to the possibility of any origin allowed to receive the message.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/vite/traceViewer/uiMode.CzKr-TMc.js</td><td>2</td><td>7678</td><td>RegExp() called with a `e` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/zipBundleImpl.js</td><td>1</td><td>37703</td><td>RegExp() called with a `a` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/zipBundleImpl.js</td><td>1</td><td>37748</td><td>RegExp() called with a `a` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.path-traversal.path-join-resolve-traversal.path-join-resolve-traversal</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/zipBundleImpl.js</td><td>5</td><td>5775</td><td>Detected possible user input going into a `path.join` or `path.resolve` function. This could possibly lead to a path traversal vulnerability,  where the attacker can access arbitrary files stored in the file system. Instead, be sure to sanitize or validate user input first.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.path-traversal.path-join-resolve-traversal.path-join-resolve-traversal</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/NegocioPDF.Tests/bin/Debug/net8.0/.playwright/package/lib/zipBundleImpl.js</td><td>5</td><td>6335</td><td>Detected possible user input going into a `path.join` or `path.resolve` function. This could possibly lead to a path traversal vulnerability,  where the attacker can access arbitrary files stored in the file system. Instead, be sure to sanitize or validate user input first.</td></tr><tr><td>semgrep</td><td>csharp.dotnet.security.mvc-missing-antiforgery.mvc-missing-antiforgery</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/PROYECTOPDF/Controllers/AuthController.cs</td><td>27</td><td>10</td><td>Login is a state-changing MVC method that does not validate the antiforgery token or do strict content-type checking. State-changing controller methods should either enforce antiforgery tokens or do strict content-type checking to prevent simple HTTP request types from bypassing CORS preflight controls.</td></tr><tr><td>semgrep</td><td>csharp.dotnet.security.mvc-missing-antiforgery.mvc-missing-antiforgery</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/PROYECTOPDF/Controllers/OperacionesPDFController.cs</td><td>38</td><td>2</td><td>FusionarArchivosPDF is a state-changing MVC method that does not validate the antiforgery token or do strict content-type checking. State-changing controller methods should either enforce antiforgery tokens or do strict content-type checking to prevent simple HTTP request types from bypassing CORS preflight controls.</td></tr><tr><td>semgrep</td><td>csharp.dotnet.security.mvc-missing-antiforgery.mvc-missing-antiforgery</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/PROYECTOPDF/Controllers/OperacionesPDFController.cs</td><td>95</td><td>2</td><td>CortarArchivoPDF is a state-changing MVC method that does not validate the antiforgery token or do strict content-type checking. State-changing controller methods should either enforce antiforgery tokens or do strict content-type checking to prevent simple HTTP request types from bypassing CORS preflight controls.</td></tr><tr><td>semgrep</td><td>csharp.dotnet.security.mvc-missing-antiforgery.mvc-missing-antiforgery</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/PROYECTOPDF/Controllers/OperacionesPDFController.cs</td><td>149</td><td>2</td><td>ObtenerTotalPaginas is a state-changing MVC method that does not validate the antiforgery token or do strict content-type checking. State-changing controller methods should either enforce antiforgery tokens or do strict content-type checking to prevent simple HTTP request types from bypassing CORS preflight controls.</td></tr><tr><td>semgrep</td><td>csharp.dotnet.security.mvc-missing-antiforgery.mvc-missing-antiforgery</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/PROYECTOPDF/Controllers/OperacionesPDFController.cs</td><td>172</td><td>2</td><td>CargarArchivoTemporal is a state-changing MVC method that does not validate the antiforgery token or do strict content-type checking. State-changing controller methods should either enforce antiforgery tokens or do strict content-type checking to prevent simple HTTP request types from bypassing CORS preflight controls.</td></tr><tr><td>semgrep</td><td>csharp.dotnet.security.mvc-missing-antiforgery.mvc-missing-antiforgery</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/PROYECTOPDF/Controllers/RegistrationController.cs</td><td>21</td><td>6</td><td>Registrarse is a state-changing MVC method that does not validate the antiforgery token or do strict content-type checking. State-changing controller methods should either enforce antiforgery tokens or do strict content-type checking to prevent simple HTTP request types from bypassing CORS preflight controls.</td></tr><tr><td>semgrep</td><td>csharp.dotnet.security.audit.mass-assignment.mass-assignment</td><td>WARNING</td><td>MEDIUM</td><td>unknown</td><td>PROYECTO_PDF/PROYECTOPDF/Controllers/RegistrationController.cs</td><td>37</td><td>16</td><td>Mass assignment or Autobinding vulnerability in code allows an attacker to execute over-posting attacks, which could create a new parameter in the binding request and manipulate the underlying object in the application.</td></tr><tr><td>semgrep</td><td>csharp.dotnet.security.mvc-missing-antiforgery.mvc-missing-antiforgery</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/PROYECTOPDF/Controllers/SuscripcionController.cs</td><td>61</td><td>30</td><td>ConfirmarCompra is a state-changing MVC method that does not validate the antiforgery token or do strict content-type checking. State-changing controller methods should either enforce antiforgery tokens or do strict content-type checking to prevent simple HTTP request types from bypassing CORS preflight controls.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>PROYECTO_PDF/PROYECTOPDF/wwwroot/lib/jquery-validation-unobtrusive/jquery.validate.unobtrusive.js</td><td>349</td><td>17</td><td>RegExp() called with a `params` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>coveragereport/class.js</td><td>9</td><td>742</td><td>RegExp() called with a `b` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.browser.security.insecure-document-method.insecure-document-method</td><td>ERROR</td><td>LOW</td><td>unknown</td><td>coveragereport/class.js</td><td>173</td><td>9</td><td>User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities</td></tr><tr><td>semgrep</td><td>javascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>reports/coverage/class.js</td><td>9</td><td>742</td><td>RegExp() called with a `b` function argument, this might allow an attacker to cause a Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on user-controlled input, consider performing input validation or use a regex checking/sanitization library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear vulnerable to ReDoS.</td></tr><tr><td>semgrep</td><td>javascript.browser.security.insecure-document-method.insecure-document-method</td><td>ERROR</td><td>LOW</td><td>unknown</td><td>reports/coverage/class.js</td><td>173</td><td>9</td><td>User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern that can lead to XSS vulnerabilities</td></tr><tr><td>semgrep</td><td>java.lang.security.audit.xss.jsf.autoescape-disabled.autoescape-disabled</td><td>WARNING</td><td>LOW</td><td>unknown</td><td>reports/mutation/mutation-report.html</td><td>69</td><td>1</td><td>Detected an element with disabled HTML escaping. If external data can reach this, this is a cross-site scripting (XSS) vulnerability. Ensure no external data can reach here, or remove &#x27;escape=false&#x27; from this element.</td></tr></tbody></table>
                </body>
            </html>